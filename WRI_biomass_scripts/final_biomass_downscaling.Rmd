---
title: "State and County Downscaling Results Generation"
author: "Henry Strecker"
date: "March 2024"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(readxl)
library(janitor)
library(sf)
```

## Read in Required Data
```{r}
# Set up Google Drive personal path -- CHANGES PER PERSON
gdrive_path <- 'G:/.shortcut-targets-by-id/1ZAqlnUns9gmR-USBe5KtSssVU_DgI5Sw'

# Read in various supply related data
runs_key <- read.csv(file.path(gdrive_path, 'WRI_biomass/RIO_data/FinalResults/runs_key.csv'))
fat_oil_grease <- read.csv(file.path(gdrive_path, 'WRI_biomass/RIO_data/FinalResults/COMMODITY_POTENTIAL.csvd/fats_oil_grease.csv'))
potential_min_cropland_change <- read.csv(file.path(gdrive_path, 'WRI_biomass/RIO_data/FinalResults/COMMODITY_POTENTIAL.csvd/potential_min_cropland_change.csv'))
biomass_feedstocks <- read.csv(file.path(gdrive_path, 'WRI_biomass/Downscaling_biomass/intermediateFiles/biomassFeedstocksAndCategories_byScenario_v2.csv'))
bts_county_data <- read.csv(file.path(gdrive_path, 'WRI_biomass/Downscaling_biomass/inputs/BTS_county_supply.csv'))

# Add switchgrass back in to the restrict scenarios
runs_key['central.restrict'][runs_key['sensitivity_key'] == 'COMMODITY_POTENTIAL--switchgrass'] <- 'min_cropland_change (llnl)' 
runs_key['slow.consumer.uptake.restrict'][runs_key['sensitivity_key'] == 'COMMODITY_POTENTIAL--switchgrass'] <- 'min_cropland_change (llnl)' 
runs_key['central.restrict.all.land'][runs_key['sensitivity_key'] == 'COMMODITY_POTENTIAL--switchgrass'] <- 'min_cropland_change (llnl)' 
runs_key['central.restrict.DAC'][runs_key['sensitivity_key'] == 'COMMODITY_POTENTIAL--switchgrass'] <- 'min_cropland_change (llnl)' 
runs_key['slow.consumer.uptake.restrict.DAC'][runs_key['sensitivity_key'] == 'COMMODITY_POTENTIAL--switchgrass'] <- 'min_cropland_change (llnl)' 
runs_key['central.restrict.no.store'][runs_key['sensitivity_key'] == 'COMMODITY_POTENTIAL--switchgrass'] <- 'min_cropland_change (llnl)' 
runs_key['central.restrict.100p.re'][runs_key['sensitivity_key'] == 'COMMODITY_POTENTIAL--switchgrass'] <- 'min_cropland_change (llnl)' 
runs_key['low.demand.restrict'][runs_key['sensitivity_key'] == 'COMMODITY_POTENTIAL--switchgrass'] <- 'min_cropland_change (llnl)' 

# Add switchgrass-mar into biomass feedstocks
biomass_feedstocks <- biomass_feedstocks %>%
  add_row(category = 'Herbaceous energy crops', unit_conversion_category = 'Everything else', feedstock = 'switchgrass-mar',
          ira = 'zero', central = 'zero', slow.consumer.uptake = 'zero', central.restrict = 'min_cropland_change (llnl)', 
          slow.consumer.uptake.restrict = 'min_cropland_change (llnl)', central.COC = 'zero', slow.consumer.uptake.COC = 'zero')


# Preliminary cleaning for BTS data
bts_county_data['Production'][bts_county_data['Production'] == 'null'] <- 0 
bts_county_data <- bts_county_data %>%
  clean_names() %>% # Rename columns
  mutate(resource = tolower(resource), # Format strings to match with existing data
         state = tolower(state), # Format strings to match with existing data
         county = str_remove(tolower(county), ' county'), # Remove trailing word county
         county = str_remove(county, ' parish'), # Remove trailing word 'parish' for LA counties
         county = str_remove(county, ' city'), # Remove trailing word 'city' for some counties
         county = replace(county, county == 'doña ana', 'dona ana'), # Replace 'ñ' with 'n'
         county = replace(county, county == 'la salle' & state == 'louisiana', 'lasalle'), # Replace in LA but not TX
         county = replace(county, county == 'james' & state == 'virginia', 'james city'), # Add back 'city' where needed
         county = replace(county, county == 'charles' & state == 'virginia', 'charles city'), # Add back 'city' where needed
         production = as.numeric(production), # Convert to numeric
         sensitivity = 'BTS [d]') 

# Read and format weight-to-area data
dry_tons_to_hectares <- read.csv(file.path(gdrive_path, 'WRI_biomass/Downscaling_biomass/inputs/landUseFactors.csv'))
dry_tons_to_acres <- dry_tons_to_hectares %>%
  mutate(Technology = tolower(Technology)) %>% # Process feedstock names to match
  slice(7:19) %>% # remove unnecessary rows
  rename(name = Technology) %>%
  select(name, landUseFactor) %>% # Remove unit column
  add_row(name = 'corn', landUseFactor = 9.3148) %>% # Researched value in US tons per hectare
  add_row(name = 'soybean oil', landUseFactor = 0.6057) %>% # Researched value in US tons per hectare
  mutate(landUseFactor = landUseFactor/2.47105) # Convert from hectares to acres

# Read in location based data
zone_mapped <- read.csv(file.path(gdrive_path, 'WRI_biomass/Downscaling_biomass/intermediateFiles/zone_mapped.csv'))
state_sqmi <- zone_mapped %>% group_by(state) %>% summarize(sqmi = sum(sqmi))
county_sqmi <- zone_mapped %>% group_by(fips, county, state) %>% summarize(sqmi = sum(sqmi)) %>% ungroup() %>% select(fips, sqmi)

county_outlines <- st_read(file.path(gdrive_path, 'WRI_biomass/Downscaling_biomass/inputs/county_outlines/tl_2016_us_county.shp')) %>%
  filter(!STATEFP %in% c('02', '11', '15', '60', '66', '69', '72', '78')) %>%
  select(fips = GEOID, geometry) %>%
  mutate(fips = as.numeric(fips)) %>%
  mutate(fips = replace(fips, fips == 46102, 46113)) # Replace the old fips code for Shannon, SD (changed in 2014)

state_outlines <- st_read(file.path(gdrive_path, 'WRI_biomass/Downscaling_biomass/inputs/state_outlines/tl_2016_us_state.shp')) %>%
  filter(!STATEFP %in% c('02', '11', '15', '60', '66', '69', '72', '78')) %>%
  select(state = NAME, geometry) %>%
  mutate(state = tolower(state))

# Create dictionary for reading in demand data later on
demand_scenario_names <- c('ira' = 'ira', 'central' = 'central', 'slow.consumer.uptake' = 'slow consumer uptake',
                           'central.restrict' = 'central restrict', 'slow.consumer.uptake.restrict' = 'slow consumer uptake restrict', 
                           'central.COC' = 'central COC', 'slow.consumer.uptake.COC' = 'slow consumer uptake COC',
                           'central.restrict.all.land' = 'central restrict all land', 'central.restrict.DAC' = 'central restrict DAC',
                           'slow.consumer.uptake.restrict.DAC' = 'slow consumer uptake restrict DAC',
                           'central.restrict.no.store' = 'central restrict no store', 
                           'central.restrict.100p.re' = 'central restrict 100p re', 'low.demand.restrict' = 'low demand restrict')

```


## Define a Function to Run the Whole Process
```{r}
biomass_downscaling <- function(scenario_list){
  for (scenario in scenario_list){
    
    writeLines(paste('Generating downscaling results for the', scenario, 'scenario.'))
    
    ######## Parse runs_key
    
    runs_key_select <- runs_key %>% 
      separate(sensitivity_key, c("dataType", "feedstock"), sep = "--") %>% # Parse feedstock from data type
      filter(dataType == "COMMODITY_POTENTIAL") %>% # Select only commodity_potential
      filter(get(scenario) %in% c("ICCT x2 [d]", "BTS [d]", "min_cropland_change (llnl)", "3x expanded corn")) # Select current scenario in our three supply curve sources 


    ######## Combine non-BTS for scenario filtering and eventual splitting to oils or LLNL
    
    combined_supply <- rbind(fat_oil_grease, potential_min_cropland_change) %>%
      filter(name %in% unique(biomass_feedstocks$feedstock)) %>% 
      left_join(runs_key_select %>% select(name = feedstock, all_of(scenario)), by = 'name') %>%
      filter(sensitivity == get(scenario)) # Filter for rows in desired scenario
    
    soy_oil_scenario <- combined_supply %>% 
      filter(get(scenario) == 'ICCT x2 [d]', # Select oils data
             year == 2032) %>%  # Select farthest out year to project for 2035 and 2050
      select(-scenario) %>% # Remove duplicate column
      rename(state = gau) # Rename for join in next step

    llnl_scenario <- combined_supply %>% 
      filter(gau != 'missing', get(scenario) == 'min_cropland_change (llnl)') %>% # Select LLNL data
      select(-scenario) %>% # Remove duplicate column
      separate(gau, c("county", "state"), sep = ", ") %>% # Parse for later joining
      mutate(name = case_when(
        name == 'beef ' ~ 'beef', # Remove trailing space in name
        TRUE ~ name))
    
    
    ######## Processing BTS County Data
    
    # Create variable that lists all BTS feedstocks in the current scenario
    bts_feedstocks <- unique(runs_key_select %>% filter(get(scenario) == 'BTS [d]') %>% select(feedstock))$feedstock
    
    # Pull county level data and format everything to match up with zone_mapped later 
    bts_county_clean <- bts_county_data %>%
      filter(resource %in% c(bts_feedstocks, 'corn')) %>% # Filter for relevant feedstocks
      select(resource, year, biomass_price, state, county, production, production_unit) %>% # Only relevant columns
      rename(name = resource,
             bin = biomass_price,
             value = production) %>%
      group_by(name, year, bin, state, county, production_unit) %>%
      summarize_at('value', sum) %>% # Combine rows with split production values within the same county
      ungroup() %>%
      group_by(name, year, state, county) %>% # Set up to reverse cumulative sum across bins
      arrange(bin) %>% # Set bin values in order
      mutate(value = c(value[1], c(value - lag(value))[-1])) %>% # Method to undo cumulative sum
      mutate(value = case_when(value <= 0 ~ 0, # Set all negatives to 0
                               TRUE ~ value)) %>% # Leave values > 0 as they were
      ungroup() %>%
      mutate(bin = case_when(name == 'corn' ~ 1, # Complete corn bin alignment here so that zone totals are accurate
                             TRUE ~ bin)) %>%
      group_by(name, year, bin, state, county, production_unit) %>%
      summarize(value = sum(value)) %>% # Combine all previous corn bin values into a single bin
      ungroup()

    bts_county_clean <- bts_county_clean %>%
      rbind(bts_county_clean %>% filter(name == 'corn') %>% mutate(bin = 2), # Duplicate bin 1 data for other bins
            bts_county_clean %>% filter(name == 'corn') %>% mutate(bin = 3))
    
    
    ######## Combine data cleaning results with county/state data
    
    soy_oil_scenario <- left_join(soy_oil_scenario, zone_mapped, by = 'state') # Oils are state level
    llnl_scenario <- left_join(llnl_scenario, zone_mapped, by = c('state', 'county')) # LLNL is county level
    bts_scenario <- left_join(bts_county_clean, zone_mapped, by = c('state', 'county')) # BTS is county level
    
    
    ######## Calculate zone supply totals for each feedstock, bin, year combination
    
    # Here every state & county combination has total state supply as its value, so special measures were taken to prevent double counting
    soy_oil_zone_sum <- soy_oil_scenario %>%
      mutate(value = value * state_area_prop) %>% # Calculate state supply for its current zone
      group_by(name, bin, year, zone, state) %>%
      summarize_at(vars(value), mean) %>% # Aggregate from counties to state so that state values are not repeatedly summed
      ungroup(state) %>% # Now ungroup state
      summarize_at(vars(value), sum) %>% # Zone totals now are based on summed up state-wide values
      rename(zone_total = value)
    
    # Here every county & state combination has its own supply value, but some counties exist across zones with differing overlap percentages
    # Need to scale the value for each county by its overlap percentage so that there's no double counting supply across differing zones
    # A good example to check for this is Kern, CA because it's in both north and south CA zones
    llnl_zone_sum <- llnl_scenario %>%
      mutate(value = value * county_area_prop) %>% # Calculate county supply for its current zone
      group_by(name, bin, year, zone) %>%
      summarize_at('value', sum) %>% # Sum all counties within the same zone
      rename(zone_total = value) %>%
      ungroup()
    
    # The process for LLNL is repeated here
    bts_zone_sum <- bts_scenario %>%
      mutate(value = value * county_area_prop) %>%
      group_by(name, bin, year, zone) %>%
      summarize_at('value', sum) %>%
      rename(zone_total = value) %>%
      ungroup()
    
    
    ######## Calculate state/county supply contribution toward zone total
    
    ## Finalize fat, oil, and grease data
    soy_oil_supply_prop <- left_join(soy_oil_scenario, soy_oil_zone_sum, by = c('name', 'year', 'bin', 'zone')) %>% # Add zone total data
      mutate(value = value * state_area_prop, # Scale state-wide supply by its overlap percentage first
             state_zone_contribution = value/zone_total, # Scale state contribution by zone total
             state_zone_contribution = replace(state_zone_contribution, state_zone_contribution == 'NaN', 0), # Set division by zero to 0
             year = 2035) # Set 2032 data as our 2035 values
    
    # Need to use 2035 data as a proxy for 2050
    soy_oil_supply_prop <- rbind(soy_oil_supply_prop, soy_oil_supply_prop %>% mutate(year = 2050)) %>% # Duplicate data for 2050
      group_by(name, state, year, zone) %>%
      summarize_at('state_zone_contribution', mean) %>% # Proportion is identical for each bin
      ungroup()
    
    ## Finalize LLNL data
    llnl_supply_prop <- left_join(llnl_scenario, llnl_zone_sum, by = c('name', 'year', 'bin', 'zone')) %>% # Add zone total data
      mutate(value = value * county_area_prop, # Scale county-wide supply by its overlap percentage first
             county_zone_contribution = value/zone_total, # Calculate county contributions
             year = replace(year, year == 2040, 2050), # Adjust beef, swine, dairy to be 2050
             year = replace(year, name == 'switchgrass-mar', 2050)) %>% # Adjust switchgrass-mar to 2050
      filter(year == 2050) %>% # Select only this data which will also be used for 2035
      select(name, year, bin, zone, state, county, county_zone_contribution)
    
    # Need to use 2040/2050 data as a proxy for 2035
    llnl_supply_prop <- rbind(llnl_supply_prop, llnl_supply_prop %>% mutate(year = 2035)) 
    
    ## Finalize BTS data
    bts_supply_prop <- left_join(bts_scenario, bts_zone_sum, by = c('name', 'year', 'bin', 'zone')) %>%
      mutate(value = value * county_area_prop, # Scale county-wide supply by its overlap percentage first
             county_zone_contribution = value/zone_total,
             year = replace(year, year == 2040, 2050)) %>% # Use 2040 data as a proxy for 2050
      select(name, year, bin, zone, state, county, county_zone_contribution)
    
    
    ######## Finalize state and county level data
    
    state_level_supply <- soy_oil_supply_prop
    
    county_level_supply <- rbind(bts_supply_prop, llnl_supply_prop)
    
    # Converts alternate switchgrass naming in restrict scenarios
    county_level_supply['name'][county_level_supply['name'] == 'switchgrass-mar'] <- 'switchgrass'
    
    # Execute bin alignment for required scenarios
    if (scenario %in% c('ira', 'central', 'slow.consumer.uptake', 'central.COC', 'slow.consumer.uptake.COC')){
      county_level_supply <- county_level_supply %>%
        mutate(bin = case_when(
          name %in% c('switchgrass', 'miscanthus', 'wheat straw', 'corn stover', 'biomass sorghum', 
                      'sorghum stubble', 'barley straw', 'oats straw', 'energy cane') ~ bin + 50,
          name %in% c('willow', 'poplar', 'eucalyptus', 'pine') ~ bin + 40,
          name %in% c('cotton residue', 'cotton gin trash') ~ bin - 25,
          TRUE ~ bin)) # Align bin values for feedstocks that didn't match up between supply & demand
    }
    
    # Extract demand data for current scenario
    scenario_demand <- read.csv(file.path(gdrive_path, 'WRI_biomass/Downscaling_biomass/intermediateFiles/commodity_potential_y_county_level.csv')) %>% 
      filter(run.name == demand_scenario_names[scenario]) 
    
    # Converts alternate switchgrass naming in restrict scenarios
    scenario_demand['name'][scenario_demand['name'] == 'switchgrass-mar'] <- 'switchgrass'
    scenario_demand['name'][scenario_demand['name'] == 'beef '] <- 'beef'
    
    
    ######## Compute state results
    
    state_demand_totals <- scenario_demand %>% 
      filter(name %in% unique(state_level_supply$name), # Select state level feedstocks
             !state == 'district of columbia') %>% # Remove DC because it has no supply
      group_by(zone, state, name, year, bin)  %>%
      summarize(tons = mean(tons)) %>% # Summarize to the state level
      ungroup()
    
    state_level_results <- left_join(state_demand_totals, state_level_supply, # Join supply and demand
                                     by = c('zone', 'state', 'name', 'year')) %>%
      mutate(tons_of_production = tons * state_zone_contribution) %>% # Calculate each state's contribution to the zone
      left_join(state_sqmi, by = 'state')
    
    
    
    ######## Compute county results
    
    county_level_results <- left_join(scenario_demand %>% filter(name %in% unique(county_level_supply$name)), #Filter for county-specific feedstocks
                                      county_level_supply, 
                                      by = c('name', 'year', 'bin', 'zone', 'state', 'county'))
    
    county_level_results <- county_level_results %>% 
      drop_na(county_zone_contribution) %>% # Drop all rows that don't contribute to production totals
      mutate(tons_of_production = tons * county_zone_contribution) %>% # Calculate county contributions to total zone tonnage
      left_join(zone_mapped %>% select(fips, zone, sqmi), by = c('fips', 'zone'))
    
    ######## Quality check results
    
    # Checks that individual state totals equal expected zone totals
    state_final_check <- state_level_results %>%
      group_by(zone, name, year, bin) %>%
      summarize(tons = mean(tons), # Create column for zone total
                tons_of_production = sum(tons_of_production)) %>% # Creates column for state totals summed across the whole zone
      ungroup()
    
    if (dim(state_final_check[round(state_final_check$tons, 3) != round(state_final_check$tons_of_production, 3), ])[1] != 0){
      print('Warning, state and zone totals do not match')
    }
    
    # Checks that individual county totals equal expected zone totals
    county_final_check <- county_level_results %>%
      group_by(zone, name, year, bin) %>%
      summarize(tons = mean(tons), # Create column for zone total
                tons_of_production = sum(tons_of_production)) %>% # Creates column for county totals summed across the whole zone
      ungroup()
    
    if (dim(county_final_check[round(county_final_check$tons, 5) != round(county_final_check$tons_of_production, 5), ])[1] != 0){
      print('Warning, county and zone totals do not match')
    }
    
    
    ######## Summarize across bins and calculate acreage for relevant feedstocks
    
    state_level_results <- state_level_results %>%
      group_by(zone, state, name, year) %>%
      summarize(tons_of_production = sum(tons_of_production)) %>% # Sum across bins
      ungroup()
    
    county_level_results <- county_level_results %>%
      group_by(zone, state, county, fips, name, year) %>%
      summarize(tons_of_production = sum(tons_of_production, na.rm = TRUE)) %>% # Sum across bins
      ungroup()
      
    
    ######## Proportionally spread remaining feedstocks across the whole zone where no supply data was available
    
    #### State Level
    # Calculate total predicted demand for each feedstock-zone combination
    zone_demand_totals_nobin <- scenario_demand %>%
      filter(name %in% unique(state_level_supply$name)) %>%
      group_by(zone, name, year, bin) %>%
      summarize(tons = mean(tons)) %>%
      ungroup(bin) %>%
      summarize(tons = sum(tons)) %>%
      ungroup()
    
    # Calculate total modeled demand for each feedstock-zone combination
    final_state_totals_nobin <- state_level_results %>%
      group_by(zone, name, year) %>%
      summarize(tons = sum(tons_of_production)) %>%
      ungroup()
    
    # Join the above data frames to compare
    final_demand_difference <- zone_demand_totals_nobin %>%
      left_join(final_state_totals_nobin, by = c('zone', 'name', 'year'))
    
    # Create a list of all feedstock-zone combinations that don't currently have any modeled demand
    missing_supply_data <- final_demand_difference[is.na(final_demand_difference$tons.y), ]
    
    if (nrow(missing_supply_data) > 0){
      for (row in 1:nrow(missing_supply_data)){
        rows_to_add <- left_join(missing_supply_data[row, ], zone_mapped, by = 'zone')
        rows_to_add <- rows_to_add %>%
          mutate(tons_of_production = tons.x * sqmi / sum(rows_to_add$sqmi)) %>%
          select(zone, state, county, fips, name, year, tons_of_production)
        
        state_level_results <- rbind(state_level_results, rows_to_add)
      }
    }
    
    
    #### County Level
    # Calculate total predicted demand for each feedstock-zone combination
    zone_demand_totals_nobin <- scenario_demand %>%
      filter(name %in% unique(county_level_supply$name)) %>%
      group_by(zone, name, year, bin) %>%
      summarize(tons = mean(tons)) %>%
      ungroup(bin) %>%
      summarize(tons = sum(tons)) %>%
      ungroup()
    
    # Calculate total modeled demand for each feedstock-zone combination
    final_county_totals_nobin <- county_level_results %>%
      group_by(zone, name, year) %>%
      summarize(tons = sum(tons_of_production)) %>%
      ungroup()
    
    # Join the above data frames to compare
    final_demand_difference <- zone_demand_totals_nobin %>%
      left_join(final_county_totals_nobin, by = c('zone', 'name', 'year'))
    
    # Create a list of all feedstock-zone combinations that don't currently have any modeled demand
    missing_supply_data <- final_demand_difference[is.na(final_demand_difference$tons.y), ]
    
    # If needed, proportionally spread tons across all counties within the zone
    if (nrow(missing_supply_data > 0)){
      for (row in 1:nrow(missing_supply_data)){
        rows_to_add <- left_join(missing_supply_data[row, ], zone_mapped, by = 'zone')
        rows_to_add <- rows_to_add %>%
          mutate(tons_of_production = tons.x * sqmi / sum(rows_to_add$sqmi)) %>%
          select(zone, state, county, fips, name, year, tons_of_production)
        
        county_level_results <- rbind(county_level_results, rows_to_add)
      }
    }
    
    
    ######## Proportionally spread remaining feedstocks across available counties where incomplete supply data was available
    
    #### State level
    zone_demand_totals_nobin <- scenario_demand %>%
      filter(name %in% unique(state_level_supply$name)) %>%
      group_by(zone, name, year, bin) %>%
      summarize(tons = mean(tons)) %>%
      ungroup(bin) %>%
      summarize(tons = sum(tons)) %>%
      ungroup()
    
    # Calculate total modeled demand for each feedstock-zone combination
    final_state_totals_nobin <- state_level_results %>%
      group_by(zone, name, year) %>%
      summarize(tons = sum(tons_of_production)) %>%
      ungroup()
    
    # Join the above data frames to compare
    final_demand_difference <- zone_demand_totals_nobin %>%
      left_join(final_state_totals_nobin, by = c('zone', 'name', 'year'))
    
    # Gather all feedstock-zone combinations where demand is still not being met
    incomplete_supply <- final_demand_difference[round(final_demand_difference$tons.x, 2) != round(final_demand_difference$tons.y, 2), ]
    
    if (nrow(incomplete_supply > 0)){
      for (row in 1:nrow(incomplete_supply)){
        demand_total <- incomplete_supply$tons.x[row]
        current_total <- incomplete_supply$tons.y[row]
        
        # Scale up county results by their zone contribution to meet total demand
        state_level_results <- state_level_results %>% 
          mutate(tons_of_production = case_when(
            (zone == incomplete_supply$zone[row] & name == incomplete_supply$name[row] &
            year == incomplete_supply$year[row]) ~ (tons_of_production/current_total)*demand_total,
            TRUE ~ tons_of_production))
      }
    }
    
    ## Check that the above processes worked
    final_state_totals_nobin <- state_level_results %>%
      group_by(zone, name, year) %>%
      summarize(tons = sum(tons_of_production)) %>%
      ungroup()
    
    # Join the above data frames to compare
    final_demand_difference <- zone_demand_totals_nobin %>%
      left_join(final_state_totals_nobin, by = c('zone', 'name', 'year'))
    
    if (dim(final_demand_difference[round(final_demand_difference$tons.x, 2) != round(final_demand_difference$tons.y, 2), ])[1] != 0){
      print('Warning: Final state demand was not accurately met')
    }
    
    
    #### County level
    
    zone_demand_totals_nobin <- scenario_demand %>%
      filter(name %in% unique(county_level_supply$name)) %>%
      group_by(zone, name, year, bin) %>%
      summarize(tons = mean(tons)) %>%
      ungroup(bin) %>%
      summarize(tons = sum(tons)) %>%
      ungroup()
    
    final_county_totals_nobin <- county_level_results %>%
      group_by(zone, name, year) %>%
      summarize(tons = sum(tons_of_production)) %>%
      ungroup()
    
    final_demand_difference <- zone_demand_totals_nobin %>%
      left_join(final_county_totals_nobin, by = c('zone', 'name', 'year'))
    
    # Gather all feedstock-zone combinations where demand is still not being met
    incomplete_supply <- final_demand_difference[round(final_demand_difference$tons.x, 2) != round(final_demand_difference$tons.y, 2), ]
    
    if (nrow(incomplete_supply > 0)){
      for (row in 1:nrow(incomplete_supply)){
        demand_total <- incomplete_supply$tons.x[row]
        current_total <- incomplete_supply$tons.y[row]
        
        # Scale up county results by their zone contribution to meet total demand
        county_level_results <- county_level_results %>% 
          mutate(tons_of_production = case_when(
            (zone == incomplete_supply$zone[row] & name == incomplete_supply$name[row] &
            year == incomplete_supply$year[row]) ~ (tons_of_production/current_total)*demand_total,
            TRUE ~ tons_of_production))
      }
    }
    
    ## Check that the above processes worked
    final_county_totals_nobin <- county_level_results %>%
      group_by(zone, name, year) %>%
      summarize(tons = sum(tons_of_production)) %>%
      ungroup()
    
    final_demand_difference <- zone_demand_totals_nobin %>%
      left_join(final_county_totals_nobin, by = c('zone', 'name', 'year'))
    
    if (dim(final_demand_difference[round(final_demand_difference$tons.x, 5) != round(final_demand_difference$tons.y, 5), ])[1] != 0){
      print('Warning: Final county demand was not accurately met')
    }

    
    ######## Add columns for feedstock category
    
    state_level_results <- state_level_results %>%
      mutate(category = 'Vegetable Oil')
    
    county_level_results <- county_level_results %>%
      mutate(category = case_when(
        name %in% c('barley straw', 'beef', 'citrus residues', 'corn stover', 'cotton gin trash', 'cotton residue', 'dairy',
                    'noncitrus residues', 'oats straw', 'rice hulls', 'rice straw', 'sorghum stubble', 'sugarcane bagasse',
                    'sugarcane trash', 'swine', 'tree nut residues', 'wheat straw') ~ 'Agricultural waste and residues',
        name == 'corn' ~ 'Food Crop',
        name %in% c('hardwood, lowland logging residues', 'hardwood, upland logging residues', 'mixedwood logging residues',
                    'other forest residue', 'other forest thinnings', 'primary mill residue', 'secondary mill residue',
                    'softwood, natural logging residues', 'softwood, planted logging residues') ~ 'Forestry waste and residues',
        name %in% c('biomass sorghum', 'energy cane', 'existing herbaceous biomass', 'miscanthus', 
                    'switchgrass') ~ 'Herbaceous - energy crop',
        name %in% c('construction & demolition waste', 'landfill gas', 'municipal solid waste wood', 'non food biogenic msw',
                    'non-residential food waste', 'other municipal solid waste', 'residential food waste', 'textiles',
                    'yard trimmings') ~ 'Municipal waste and residues',
        name %in% c('existing woody biomass', 'hardwood, lowland whole trees', 'hardwood, upland whole trees', 'mixedwood whole trees',
                    'pnw foretry 1', 'pnw foretry 2', 'pnw foretry 3', 'pnw foretry 4', 'pnw foretry 5', 'pnw foretry 6',
                    'softwood, natural whole trees', 'softwood, planted whole trees') ~ 'Woody',
        name %in% c('eucalyptus', 'pine', 'poplar', 'willow') ~ 'Woody - Purpose-grown/energy crop')
        )
    
    ######## Join state and county acreage conversions, outlines
    
    final_state <- state_level_results %>%
      left_join(state_sqmi, by = 'state') %>%
      left_join(dry_tons_to_acres, by = 'name') %>% # Add ton to acre conversion column
      mutate(production_acres = tons_of_production / landUseFactor) %>% # Calculate acreage
      left_join(state_outlines, by = 'state')
    
    final_county <- county_level_results %>%
      left_join(county_sqmi, by = 'fips') %>% 
      left_join(dry_tons_to_acres, by = 'name') %>% # Add ton to acre conversion column
      mutate(production_acres = tons_of_production / landUseFactor) # Calculate crop acreage

    
    ######## Revert switchgrass feedstock name where appropriate
    if(scenario %in% c('central.restrict', 'slow.consumer.uptake.restrict', 'central.restrict.all.land', 
                       'central.restrict.DAC', 'slow.consumer.uptake.restrict.DAC', 
                       'central.restrict.no.store', 'central.restrict.100p.re', 'low.demand.restrict')){
      final_county['name'][final_county['name'] == 'switchgrass'] <- 'switchgrass-mar' 
    }
    
    
    ######## Organize columns before writing output
    
    final_state <- final_state %>%
      select(zone, state, sqmi, year, category, name, tons_of_production, land_use_factor = landUseFactor, production_acres, geometry)
    
    final_county <- final_county %>%
      select(zone, state, fips, county, sqmi, year, category, name, tons_of_production, land_use_factor = landUseFactor, production_acres)
    
    
    ######## Write results to Google Drive
    
    write_sf(final_state, file.path(gdrive_path, 'WRI_biomass/Downscaling_biomass/outputs', paste('state_results_', scenario, '.shp', sep = '')))
    write_csv(final_county, file.path(gdrive_path, 'WRI_biomass/Downscaling_biomass/outputs', paste('county_results_', scenario, '.csv', sep = '')))
        
    writeLines(paste('Finished writing downscaling output for the', scenario, 'scenario.\n'))
    
  }
}

```


## Run Function and Produce Output
```{r, warning=FALSE, message=FALSE}
# Select the scenarios for which you want to produce results
# All possible scenarios: 'ira', 'central', 'slow.consumer.uptake', 'central.restrict', 'slow.consumer.uptake.restrict', 'central.COC', 'slow.consumer.uptake.COC', 'central.restrict.all.land', 'central.restrict.DAC', 'slow.consumer.uptake.restrict.DAC', 'central.restrict.no.store', 'central.restrict.100p.re', 'low.demand.restrict'
scenarios <- c('ira', 'central', 'slow.consumer.uptake', 'central.restrict', 'slow.consumer.uptake.restrict', 'central.COC', 'slow.consumer.uptake.COC', 'central.restrict.all.land', 'central.restrict.DAC', 'slow.consumer.uptake.restrict.DAC', 'central.restrict.no.store', 'central.restrict.100p.re', 'low.demand.restrict')

# Run downscaling
biomass_downscaling(scenarios)

```

